# Task 8: Terminal Theme Implementation

**Epic**: menu-interface  
**Created**: 2025-09-03T18:46:59Z  
**Updated**: 2025-09-03T19:11:14Z  
**GitHub**: https://github.com/AngelOnFira/macroquad-mech-2025/issues/8  
**Status**: planned  
**Priority**: medium  
**Effort**: 5 hours  
**Depends On**: [5]  
**Parallel**: true  

## Overview

Implement a custom egui theme that creates a terminal/retro-futuristic aesthetic for the menu system. This theme will establish the visual identity of the game's interface and provide an immersive sci-fi atmosphere consistent with the mech battle setting.

## Objectives

- Design and implement a cohesive terminal-inspired visual theme
- Create custom egui styling with retro-futuristic elements
- Ensure accessibility while maintaining aesthetic goals
- Provide consistent theming across all menu components
- Support both light and dark theme variants

## Technical Requirements

### Visual Design Elements

1. **Color Palette**
   ```rust
   pub struct TerminalTheme {
       // Primary colors
       background: Color32,        // Deep dark blue/black
       surface: Color32,          // Slightly lighter panels  
       primary: Color32,          // Bright cyan/green accent
       secondary: Color32,        // Orange/amber warnings
       
       // Text colors
       text_primary: Color32,     // Bright white/cyan
       text_secondary: Color32,   // Dimmed gray
       text_disabled: Color32,    // Dark gray
       
       // Interactive states
       hover: Color32,            // Highlighted cyan
       active: Color32,           // Pressed state
       focus: Color32,            // Keyboard focus indicator
       
       // Semantic colors
       success: Color32,          // Green confirmation
       warning: Color32,          // Amber caution
       error: Color32,            // Red alerts
   }
   ```

2. **Typography System**
   - **Primary Font**: Monospace (terminal aesthetic)
   - **Secondary Font**: Sans-serif (for accessibility)
   - **Font Sizes**: Hierarchical scale (12pt, 14pt, 16pt, 20pt, 24pt)
   - **Text Effects**: Subtle glow, scanline effects

3. **Visual Effects**
   - **Borders**: Glowing outlines with gradient falloff
   - **Backgrounds**: Subtle scan-line patterns
   - **Animations**: CRT-style flicker effects (subtle)
   - **Shadows**: Colored drop shadows for depth

### Theme Architecture

1. **ThemeManager**
   ```rust
   pub struct ThemeManager {
       current_theme: TerminalTheme,
       theme_variant: ThemeVariant,
       custom_fonts: HashMap<String, FontDefinition>,
       effect_settings: EffectSettings,
   }
   
   pub enum ThemeVariant {
       Classic,     // Green on black
       Modern,      // Cyan on dark blue  
       Amber,       // Orange on brown
       Accessible,  // High contrast
   }
   ```

2. **Custom Widget Styling**
   ```rust
   pub trait TerminalStyled {
       fn apply_terminal_style(&mut self, ui: &mut egui::Ui, theme: &TerminalTheme);
   }
   
   // Implement for common widgets
   impl TerminalStyled for Button { ... }
   impl TerminalStyled for TextEdit { ... }
   impl TerminalStyled for Slider { ... }
   ```

3. **Effect System**
   ```rust
   pub struct EffectSettings {
       glow_intensity: f32,
       scanline_opacity: f32,
       flicker_enabled: bool,
       animation_speed: f32,
   }
   ```

### Integration Points

- Apply theme to all menu states from Task 5
- Integrate with settings system for theme selection
- Work with keyboard navigation focus indicators
- Support dynamic theme switching

## Implementation Plan

### Phase 1: Core Theme System (1.5 hours)
1. Define color palette and theme structure
2. Create ThemeManager and variant system
3. Implement basic egui style overrides
4. Set up font loading and management

### Phase 2: Widget Styling (2 hours)
1. Create custom styles for buttons, text, panels
2. Implement glowing borders and effects
3. Add hover and focus state styling
4. Create consistent spacing and layout rules

### Phase 3: Visual Effects (1 hour)
1. Implement subtle glow effects for text and borders
2. Add optional scanline background patterns
3. Create smooth color transition animations
4. Add CRT-style visual flourishes (very subtle)

### Phase 4: Integration & Polish (0.5 hours)
1. Apply theme to all existing menu components
2. Test theme variants for accessibility
3. Performance optimization for effects
4. Documentation and style guide creation

## Acceptance Criteria

### Visual Consistency
- [ ] All menu elements follow consistent color scheme
- [ ] Typography hierarchy is clear and readable
- [ ] Interactive elements have clear state changes
- [ ] Spacing and alignment create visual harmony
- [ ] Theme works across different screen sizes

### Technical Implementation
- [ ] Theme can be changed at runtime without restart
- [ ] Custom fonts load correctly and fallback gracefully
- [ ] Visual effects don't impact menu performance
- [ ] Theme integrates with existing egui patterns
- [ ] Memory usage remains reasonable with effects enabled

### Accessibility
- [ ] Text contrast meets WCAG AA standards
- [ ] Color-blind friendly palette options
- [ ] Focus indicators are clearly visible
- [ ] Theme doesn't rely solely on color for information
- [ ] High contrast mode available

### User Experience
- [ ] Theme enhances immersion without hindering usability
- [ ] Visual effects are subtle and not distracting
- [ ] Theme variants provide meaningful choices
- [ ] Performance impact is negligible
- [ ] Theme feels consistent with game's sci-fi setting

## Testing Strategy

### Visual Testing
- Screenshot comparison across theme variants
- Contrast ratio validation for text elements
- Color palette verification in different lighting conditions
- Animation smoothness and performance testing

### Accessibility Testing
- Screen reader compatibility with themed elements
- High contrast mode validation
- Color-blind simulation testing
- Keyboard navigation visibility testing

### Performance Testing
- Frame rate impact measurement with effects enabled
- Memory usage monitoring for custom fonts and effects
- Theme switching performance testing
- Large menu rendering performance

### Manual Testing Scenarios
1. Navigate through all menus with each theme variant
2. Test theme switching during gameplay
3. Verify readability in different lighting conditions
4. Check visual consistency across all menu states
5. Test with accessibility tools and screen readers

## Known Challenges

### Technical Challenges
- **egui Limitations**: Working within egui's styling constraints
- **Performance Balance**: Rich visual effects vs. smooth performance
- **Font Loading**: Ensuring custom fonts load reliably
- **Color Management**: Consistent colors across different displays

### Design Challenges
- **Readability vs. Style**: Balancing aesthetics with usability
- **Effect Subtlety**: Avoiding visual fatigue from overdone effects  
- **Accessibility**: Meeting standards while maintaining theme identity
- **Consistency**: Ensuring all widgets follow theme rules

## Dependencies

- **Task 5 (Main Menu)**: Provides menu structure to apply theming
- **egui framework**: Core styling and widget systems
- **Font resources**: Monospace and fallback font files
- **Graphics system**: For any custom effect rendering

## Success Metrics

- Theme enhances game atmosphere without usability loss
- All accessibility standards met in high contrast mode
- Theme switching works smoothly without visual glitches
- Visual effects add polish without performance cost
- User feedback indicates improved immersion

## Future Extensions

- **Animated Backgrounds**: Subtle particle effects or data streams
- **Sound Integration**: Audio feedback matching visual theme
- **Dynamic Theming**: Theme changes based on game state/context
- **User Customization**: Allow players to create custom color schemes
- **Seasonal Themes**: Special themes for events or game modes

## Style Guide Reference

### Color Usage Guidelines
- **Primary**: Main interactive elements, selected states
- **Secondary**: Warnings, important information, accents
- **Background**: Main surfaces, content areas
- **Text**: Hierarchical importance (primary > secondary > disabled)

### Typography Rules
- **Headers**: Primary font, larger sizes, optional glow
- **Body Text**: Secondary font for readability, standard sizes
- **Code/Data**: Monospace font, technical information display
- **Labels**: Secondary font, smaller sizes, muted colors

### Effect Application
- **Glow**: Primary interactive elements, focus indicators
- **Scanlines**: Large background areas only, very subtle
- **Animations**: State transitions, loading indicators
- **Borders**: Panel separation, element highlighting