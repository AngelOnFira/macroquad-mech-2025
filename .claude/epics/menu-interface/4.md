---
name: Settings Data Model
status: open
created: 2025-09-03T18:46:59Z
updated: 2025-09-03T19:11:14Z
github: https://github.com/AngelOnFira/macroquad-mech-2025/issues/4
depends_on: [3]
parallel: true
conflicts_with: []
last_sync: 2025-09-04T12:56:10Z
---

# Task 4: Settings Data Model

## Overview
Create a comprehensive settings data structure with local storage persistence. This provides the data layer for game configuration independent of the UI implementation.

## Current State
- No centralized settings system exists
- Game configuration is hardcoded or environment-based
- No persistence mechanism for user preferences

## Objective
Implement a robust settings data model with automatic persistence to localStorage/file system, supporting all configurable game aspects.

## Technical Requirements

### 1. Settings Structure
Create `client/src/settings.rs` with comprehensive settings:
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GameSettings {
    pub graphics: GraphicsSettings,
    pub audio: AudioSettings,
    pub controls: ControlSettings,
    pub gameplay: GameplaySettings,
    pub network: NetworkSettings,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphicsSettings {
    pub resolution: (u32, u32),
    pub fullscreen: bool,
    pub vsync: bool,
    pub render_distance: u32,
    pub show_fps: bool,
    pub ui_scale: f32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AudioSettings {
    pub master_volume: f32,
    pub sfx_volume: f32,
    pub music_volume: f32,
    pub voice_volume: f32,
    pub mute_when_unfocused: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ControlSettings {
    pub mouse_sensitivity: f32,
    pub invert_mouse: bool,
    pub key_bindings: HashMap<Action, KeyCode>,
    pub gamepad_enabled: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GameplaySettings {
    pub show_damage_numbers: bool,
    pub show_teammate_outlines: bool,
    pub auto_pickup_resources: bool,
    pub confirm_destructive_actions: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]  
pub struct NetworkSettings {
    pub server_url: String,
    pub auto_reconnect: bool,
    pub connection_timeout_ms: u32,
    pub preferred_name: String,
}
```

### 2. Persistence Layer
```rust
impl GameSettings {
    pub fn load() -> Result<Self, SettingsError>
    pub fn save(&self) -> Result<(), SettingsError>
    pub fn reset_to_defaults() -> Self
    pub fn validate(&self) -> Result<(), Vec<ValidationError>>
}
```

### 3. Platform-Specific Storage
- **WASM**: Use localStorage via web-sys
- **Native**: Use config file in user directory
- Graceful fallback to defaults if storage fails

### 4. Reactive Settings
```rust
pub struct SettingsManager {
    settings: GameSettings,
    callbacks: HashMap<SettingPath, Vec<SettingsCallback>>,
}

impl SettingsManager {
    pub fn register_callback<F>(&mut self, path: SettingPath, callback: F)
    pub fn update_setting(&mut self, path: SettingPath, value: SettingValue) -> Result<(), SettingsError>
    pub fn get_setting(&self, path: SettingPath) -> Option<&SettingValue>
}
```

## Acceptance Criteria

1. **Complete Settings Structure**: All major game aspects have configurable settings
2. **Persistence Works**: Settings save/load correctly on both WASM and native
3. **Default Values**: Sensible defaults work out of the box
4. **Validation**: Invalid settings are caught and handled gracefully
5. **Type Safety**: Settings use appropriate types with compile-time checks
6. **Error Recovery**: Corrupted settings files don't crash the application
7. **Performance**: Settings access is fast (<1ms for any get/set operation)
8. **Memory Efficient**: Settings structure uses minimal memory

## Technical Details

### Storage Paths
- **Native**: `~/.local/share/mech-battle-arena/settings.json` (Linux)
- **Native**: `%APPDATA%/MechBattleArena/settings.json` (Windows)  
- **WASM**: `localStorage['mech-battle-arena-settings']`

### Error Handling
```rust
#[derive(Debug, Clone)]
pub enum SettingsError {
    StorageNotAvailable,
    InvalidFormat(String),
    ValidationFailed(Vec<ValidationError>),
    IOError(String),
}

#[derive(Debug, Clone)]
pub enum ValidationError {
    InvalidRange { field: String, value: f32, min: f32, max: f32 },
    InvalidKeyBinding { action: String, key: String },
    InvalidUrl(String),
}
```

### Default Values
```rust
impl Default for GraphicsSettings {
    fn default() -> Self {
        Self {
            resolution: (1920, 1080),
            fullscreen: false,
            vsync: true,
            render_distance: 100,
            show_fps: false,
            ui_scale: 1.0,
        }
    }
}
```

### Platform Integration
```rust
#[cfg(target_arch = "wasm32")]
mod storage {
    use web_sys::{window, Storage};
    
    pub fn load_settings() -> Result<String, SettingsError> {
        let storage = get_local_storage()?;
        storage.get_item("mech-battle-arena-settings")
            .map_err(|_| SettingsError::StorageNotAvailable)?
            .ok_or(SettingsError::NotFound)
    }
}

#[cfg(not(target_arch = "wasm32"))]
mod storage {
    use std::{fs, path::PathBuf};
    use directories::ProjectDirs;
    
    pub fn load_settings() -> Result<String, SettingsError> {
        let path = get_settings_path()?;
        fs::read_to_string(path)
            .map_err(|e| SettingsError::IOError(e.to_string()))
    }
}
```

## Dependencies
- **serde**: JSON serialization/deserialization
- **directories**: Cross-platform config directories (native only)
- **web-sys**: localStorage access (WASM only)

## Effort Estimate
**3-4 hours**
- 1 hour: Design and implement core settings structures
- 1 hour: Implement persistence layer for both platforms
- 1 hour: Add validation and error handling
- 30 minutes: Write comprehensive tests
- 30 minutes: Integration and refinement

## Files to Create
- **New file**: `client/src/settings.rs` - Core implementation
- **New file**: `client/src/settings/storage.rs` - Platform-specific storage
- **New file**: `client/src/settings/validation.rs` - Settings validation
- `client/src/lib.rs` - Add settings module

## Testing Strategy
1. Unit tests for all settings structures and defaults
2. Persistence tests for both WASM and native platforms
3. Validation tests for boundary conditions
4. Error recovery tests (corrupted files, no permissions)
5. Performance tests for settings access patterns

## Integration Points
- **Task 3**: Uses AppState for settings screen state
- **Task 5**: Provides data model for settings UI
- **Renderer**: Graphics settings integration
- **Network**: Network settings integration
- **Input**: Control settings integration

## Risk Assessment
**Medium Risk** - Platform-specific storage code needs careful testing, especially WASM localStorage limitations.

## Notes
- Keep settings structure extensible for future additions
- Consider settings migrations if structure changes in future versions
- localStorage has size limits (~5MB) - monitor storage usage
- Some settings may require application restart to take effect