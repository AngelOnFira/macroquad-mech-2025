---
name: App State Extension
status: open
created: 2025-09-03T18:46:59Z
updated: 2025-09-03T19:11:14Z
github: https://github.com/AngelOnFira/macroquad-mech-2025/issues/3
depends_on: []
parallel: false
conflicts_with: []
---

# Task 3: App State Extension

## Overview
Extend the existing state machine pattern to support menu states alongside the current game state. This is the foundation task that enables menu integration without disrupting existing gameplay.

## Current State
- Client uses `GameState` struct directly in main.rs
- No state machine pattern exists currently
- All state is game-focused (players, mechs, UI)

## Objective
Create an `AppState` enum that wraps the existing `GameState` and adds menu states, providing clean separation between game and menu contexts.

## Technical Requirements

### 1. App State Enum
Create `AppState` enum in new `client/src/app_state.rs`:
```rust
pub enum AppState {
    MainMenu,
    Settings,
    Game(GameState),
    Paused(GameState),
}
```

### 2. State Transitions
Implement transition methods:
```rust
impl AppState {
    pub fn transition_to_game(&mut self) -> Result<(), StateError>
    pub fn transition_to_main_menu(&mut self) -> Result<(), StateError>
    pub fn transition_to_settings(&mut self) -> Result<(), StateError>
    pub fn pause_game(&mut self) -> Result<(), StateError>
    pub fn resume_game(&mut self) -> Result<(), StateError>
}
```

### 3. Integration Points
- Update `main.rs` to use `AppState` instead of `GameState` directly
- Ensure existing game loop logic remains unchanged when in `Game` state
- Add state-specific update/render routing

### 4. Backward Compatibility
- All existing `GameState` functionality must remain intact
- No changes to network protocol or game logic
- Minimal impact on existing rendering system

## Acceptance Criteria

1. **State Enum Created**: `AppState` enum supports all required states
2. **Transition Methods**: All state transitions work correctly and validate state changes
3. **Main.rs Integration**: Application successfully uses `AppState` wrapper
4. **Game State Preservation**: Existing game functionality works identically
5. **Error Handling**: Invalid state transitions are handled gracefully
6. **Tests Pass**: All existing tests continue to pass
7. **Memory Safety**: No additional memory overhead when in game state

## Technical Details

### Error Handling
```rust
#[derive(Debug, Clone)]
pub enum StateError {
    InvalidTransition { from: String, to: String },
    GameStateNotAvailable,
    MenuNotInitialized,
}
```

### State Validation
- MainMenu -> Game: Always allowed
- Game -> Paused: Only if game is active
- Paused -> Game: Always allowed
- Any -> Settings: Always allowed
- Settings -> Previous: Track previous state

### Performance Considerations
- Use `Box<GameState>` only if memory usage becomes an issue
- State transitions should be O(1)
- No additional allocations during game state

## Dependencies
- No external dependencies required
- Uses existing `GameState` and error handling patterns

## Effort Estimate
**2-3 hours**
- 1 hour: Create AppState enum and basic transitions
- 1 hour: Integrate with main.rs and test basic functionality  
- 30 minutes: Add error handling and validation
- 30 minutes: Testing and refinement

## Files to Modify
- `client/src/main.rs` - Update to use AppState
- `client/src/lib.rs` - Add app_state module
- **New file**: `client/src/app_state.rs` - Core implementation

## Testing Strategy
1. Unit tests for state transitions
2. Integration test for main.rs changes
3. Verify all existing game functionality works
4. Test invalid transition scenarios

## Risk Assessment
**Low Risk** - This is primarily a wrapper around existing functionality with minimal changes to core game logic.

## Notes
- This task enables all future menu functionality
- Other menu tasks (4, 5) depend on completion of this foundation
- Keep state machine simple - avoid over-engineering
- Focus on clean separation of concerns